"""
The MIT License (MIT)

Copyright (c) 2018 Andrew Wildman

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
import math

try:
    import matplotlib.pyplot as plt
except ImportError:
    raise ImportError('Matplotlib is required to run LRSpectrum')

try:
    import numpy as np
except ImportError:
    raise ImportError('Numpy is required to run LRSpectrum')


# TODO: Docstrings for class methods
# TODO: Defensive checking for all methods
class LRSpectrum(object):
    """
    LRSpectrum generates a linear response spectrum from a Gaussian log file

    Attrubutes:
        name:          Name identifier
                       string

        logfile:       Logfiles to be parsed
                       array<string>

        roots:         Poles (key, eV) and oscillator strengths (value,
                            unitless) of linear response
                       dict<string:float>

        freq:          Energy range to be plotted (eV)
                       numpy.ndarray<float>

        spect:         Spectrum generated by convolving each of the roots with
                            a given distribution such that the integral over
                            the distribution gives the oscillator strength
                       numpy.ndarray<float>

        broad:         Broadening parameter. HWHM
                       float

        wlim:          Sets bounds on energy range to generate
                       tuple<float>

        res:           Number of points per eV to evaluate
                       int

    Methods:
        parse_log():
            Parses a gaussian linear response log file. Fills roots dict.
              Called during init, but can be used to regenerate if needed.

        gen_spect(broad,wlim,res,meth):
            Generates a spectrum in the range given by wlim by convolving a
              specified distribution with each of the roots and scaling by the
              oscillator strength. Can be called multiple times to generate
              spectra with different parameters.
            broad:    Same definition as above
            wlim:     Same definition as above
            res:      Same definition as above
            meth:     Type of distribution used to broaden. Currently 'lorentz'
                        or 'gaussian' are supported. Lorentz is for time-energy
                        uncertainty broadening (lifetime) and gaussian is for
                        vibronic broadening.

        plot(xlim,ylim,xLabel,yLabel,show,lines,**kwargs):
            Plots spectrum vs frequency. Built using matplotlib.pyplot, so any
              additional arguments can be passed using kwargs
            xlim:     Limits on x axis                        tuple<float>
            ylim:     Limits on y axis                        tuple<float>
            xLabel:   Label on x axis                         string
            yLabel:   Label on y axis                         string
            show:     Whether or not to call plt.show()       bool
            lines:    Whether or not to plot lines showing    bool
                        the roots with the respective
                        oscillator strengths.

    """

    def __init__(self, name, *multLogNames):
        self.name = name
        # Support either one list of logfiles or many logfiles as params
        if isinstance(multLogNames[0], list):
            self.logfile = [self._check_log(nm) for nm in multLogNames[0]]
        elif isinstance(multLogNames[0], str):
            self.logfile = [self._check_log(nm) for nm in multLogNames]
        else:
            raise ValueError('Unexpected type for logfiles')
        self.roots = {}
        self.freq = None
        self.spect = None
        self.broad = None
        self.wlim = None
        self.res = None

        self.parse_log()

    def parse_log(self):
        for lg in self.logfile:
            lines = [line.rstrip('\n') for line in open(lg)]
            for i, line in enumerate(lines):
                # Note that the following is specific to gaussian output. If
                # the logfile output changes, this needs to as well
                if line[1:14] == 'Excited State':
                    lsp = line.split()
                    self.roots[lsp[4]] = float(lsp[8].lstrip('f='))
                    # eV and unitless

    def gen_spect(self, broad=0.5, wlim=None, res=100, meth='lorentz'):
        self.broad = broad
        # If wlim isn't given, automatically generate it based on the roots
        if wlim is None:
            rts = [float(k) for k in self.roots.keys()]
            mn = min(rts)
            mx = max(rts)
            extra = (mx-mn)*0.3
            wlim = (mn-extra, mx+extra)
        self.wlim = wlim
        self.res = int(res)
        nPts = int((wlim[1]-wlim[0])*res)
        self.freq = np.linspace(wlim[0], wlim[1], nPts)
        self.spect = np.zeros(nPts)
        ones = np.ones(nPts)
        twos = 2*ones

        for root, oscStr in self.roots.iteritems():
            if oscStr != 0:
                root = float(root)
                # Consider creating distribution functions. The only reason
                # these span lines is to increase readability
                if meth.lower() == 'lorentz':
                    # 1/(pi*broad*(1+((w-root)/broad)^2))
                    l1 = np.power((self.freq-root*ones)/broad, twos)
                    l2 = broad*np.pi*(1+l1)
                    self.spect += oscStr*np.divide(ones, l2)
                elif meth.lower() == 'gaussian':
                    # Convert from HWHM to std dev
                    stddev = broad/math.sqrt(2.0*math.log(2.0))
                    # 1/((2*pi*broad^2)^(1/2))*e^(-(w-root)^2/(2*broad^2)
                    g1 = -1*np.power(self.freq-root*ones, twos) / \
                        (2*math.pow(stddev, 2))
                    g2 = 1/(math.sqrt(2*np.pi)*stddev)*np.exp(g1)
                    self.spect += oscStr*g2
                else:
                    print('Unsupported distribution "%s" specified') % meth
                    return

    def plot(self, xlim=None, ylim=None, xLabel='Energy / eV',
             yLabel='Arbitrary Units', show=False, doSpect=True, sticks=True,
             ax=None, **kwargs):

        if self.spect is None:
            print('Spectrum must be generated prior to plotting')
            return
        if ax is None:
            ax = plt.gca()
        if xLabel:
            ax.set_xlabel(xLabel)
        if yLabel:
            ax.set_ylabel(yLabel)
        if xlim:
            ax.set_xlim(xlim)
        if ylim:
            ax.set_ylim(ylim)
        if doSpect:
            ax.plot(self.freq, self.spect, **kwargs)
        if sticks:
            for root, oscStr in self.roots.iteritems():
                ax.plot((root, root), (0, oscStr), 'k-', **kwargs)
        if show:
            plt.show()

    def _check_log(self, name):
        if name.split('.')[-1].lower() != 'log':
            raise ValueError('Non-logfile %s given' % (name))
        else:
            return name


# Default script for quick plotting
if __name__ == '__main__':
    import sys
    lr = LRSpectrum('NoName', sys.argv[1:])
    lr.gen_spect()
    lr.plot(show=True)
